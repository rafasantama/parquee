/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable, InjectionToken, Inject, Compiler } from '@angular/core';
/**
 * Token used by the ModuleMapNgFactoryLoader to load modules
 */
export const /** @type {?} */ MODULE_MAP = new InjectionToken('MODULE_MAP');
/**
 * NgModuleFactoryLoader which does not lazy load
 */
export class ModuleMapNgFactoryLoader {
    /**
     * @param {?} compiler
     * @param {?} moduleMap
     */
    constructor(compiler, moduleMap) {
        this.compiler = compiler;
        this.moduleMap = moduleMap;
    }
    /**
     * @param {?} loadChildrenString
     * @return {?}
     */
    load(loadChildrenString) {
        const /** @type {?} */ offlineMode = this.compiler instanceof Compiler;
        const /** @type {?} */ type = this.moduleMap[loadChildrenString];
        if (!type) {
            throw new Error(`${loadChildrenString} did not exist in the MODULE_MAP`);
        }
        return offlineMode ?
            this.loadFactory(/** @type {?} */ (type)) : this.loadAndCompile(/** @type {?} */ (type));
    }
    /**
     * @param {?} factory
     * @return {?}
     */
    loadFactory(factory) {
        return new Promise(resolve => resolve(factory));
    }
    /**
     * @param {?} type
     * @return {?}
     */
    loadAndCompile(type) {
        return this.compiler.compileModuleAsync(type);
    }
}
ModuleMapNgFactoryLoader.decorators = [
    { type: Injectable }
];
/** @nocollapse */
ModuleMapNgFactoryLoader.ctorParameters = () => [
    { type: Compiler },
    { type: undefined, decorators: [{ type: Inject, args: [MODULE_MAP,] }] }
];
function ModuleMapNgFactoryLoader_tsickle_Closure_declarations() {
    /** @type {?} */
    ModuleMapNgFactoryLoader.prototype.compiler;
    /** @type {?} */
    ModuleMapNgFactoryLoader.prototype.moduleMap;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kdWxlLW1hcC1uZ2ZhY3RvcnktbG9hZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbW9kdWxlcy9tb2R1bGUtbWFwLW5nZmFjdG9yeS1sb2FkZXIvc3JjL21vZHVsZS1tYXAtbmdmYWN0b3J5LWxvYWRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBT0EsT0FBTyxFQUNMLFVBQVUsRUFFVixjQUFjLEVBRWQsTUFBTSxFQUVOLFFBQVEsRUFDVCxNQUFNLGVBQWUsQ0FBQzs7OztBQU12QixNQUFNLENBQUMsdUJBQU0sVUFBVSxHQUE4QixJQUFJLGNBQWMsQ0FBQyxZQUFZLENBQUMsQ0FBQzs7OztBQU10RixNQUFNOzs7OztJQUNKLFlBQW9CLFFBQWtCLEVBQThCLFNBQW9CO1FBQXBFLGFBQVEsR0FBUixRQUFRLENBQVU7UUFBOEIsY0FBUyxHQUFULFNBQVMsQ0FBVztLQUFLOzs7OztJQUU3RixJQUFJLENBQUMsa0JBQTBCO1FBQzdCLHVCQUFNLFdBQVcsR0FBRyxJQUFJLENBQUMsUUFBUSxZQUFZLFFBQVEsQ0FBQztRQUN0RCx1QkFBTSxJQUFJLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBRWhELEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztZQUNWLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRyxrQkFBa0Isa0NBQWtDLENBQUMsQ0FBQztTQUMxRTtRQUVELE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUNsQixJQUFJLENBQUMsV0FBVyxtQkFBd0IsSUFBSSxFQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxjQUFjLG1CQUFhLElBQUksRUFBQyxDQUFDO0tBQ3pGOzs7OztJQUVPLFdBQVcsQ0FBQyxPQUE2QjtRQUMvQyxNQUFNLENBQUMsSUFBSSxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQzs7Ozs7O0lBRzFDLGNBQWMsQ0FBQyxJQUFlO1FBQ3BDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxDQUFDOzs7O1lBckJqRCxVQUFVOzs7O1lBWlQsUUFBUTs0Q0FjaUMsTUFBTSxTQUFDLFVBQVUiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmltcG9ydCB7XG4gIEluamVjdGFibGUsXG4gIE5nTW9kdWxlRmFjdG9yeUxvYWRlcixcbiAgSW5qZWN0aW9uVG9rZW4sXG4gIE5nTW9kdWxlRmFjdG9yeSxcbiAgSW5qZWN0LFxuICBUeXBlLFxuICBDb21waWxlclxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7TW9kdWxlTWFwfSBmcm9tICcuL21vZHVsZS1tYXAnO1xuXG4vKipcbiAqIFRva2VuIHVzZWQgYnkgdGhlIE1vZHVsZU1hcE5nRmFjdG9yeUxvYWRlciB0byBsb2FkIG1vZHVsZXNcbiAqL1xuZXhwb3J0IGNvbnN0IE1PRFVMRV9NQVA6IEluamVjdGlvblRva2VuPE1vZHVsZU1hcD4gPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ01PRFVMRV9NQVAnKTtcblxuLyoqXG4gKiBOZ01vZHVsZUZhY3RvcnlMb2FkZXIgd2hpY2ggZG9lcyBub3QgbGF6eSBsb2FkXG4gKi9cbkBJbmplY3RhYmxlKClcbmV4cG9ydCBjbGFzcyBNb2R1bGVNYXBOZ0ZhY3RvcnlMb2FkZXIgaW1wbGVtZW50cyBOZ01vZHVsZUZhY3RvcnlMb2FkZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvbXBpbGVyOiBDb21waWxlciwgQEluamVjdChNT0RVTEVfTUFQKSBwcml2YXRlIG1vZHVsZU1hcDogTW9kdWxlTWFwKSB7IH1cblxuICBsb2FkKGxvYWRDaGlsZHJlblN0cmluZzogc3RyaW5nKTogUHJvbWlzZTxOZ01vZHVsZUZhY3Rvcnk8YW55Pj4ge1xuICAgIGNvbnN0IG9mZmxpbmVNb2RlID0gdGhpcy5jb21waWxlciBpbnN0YW5jZW9mIENvbXBpbGVyO1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLm1vZHVsZU1hcFtsb2FkQ2hpbGRyZW5TdHJpbmddO1xuXG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bG9hZENoaWxkcmVuU3RyaW5nfSBkaWQgbm90IGV4aXN0IGluIHRoZSBNT0RVTEVfTUFQYCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZmxpbmVNb2RlID9cbiAgICAgIHRoaXMubG9hZEZhY3RvcnkoPE5nTW9kdWxlRmFjdG9yeTxhbnk+PiB0eXBlKSA6IHRoaXMubG9hZEFuZENvbXBpbGUoPFR5cGU8YW55Pj4gdHlwZSk7XG4gIH1cblxuICBwcml2YXRlIGxvYWRGYWN0b3J5KGZhY3Rvcnk6IE5nTW9kdWxlRmFjdG9yeTxhbnk+KTogUHJvbWlzZTxOZ01vZHVsZUZhY3Rvcnk8YW55Pj4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHJlc29sdmUoZmFjdG9yeSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2FkQW5kQ29tcGlsZSh0eXBlOiBUeXBlPGFueT4pOiBQcm9taXNlPE5nTW9kdWxlRmFjdG9yeTxhbnk+PiB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKHR5cGUpO1xuICB9XG59XG4iXX0=