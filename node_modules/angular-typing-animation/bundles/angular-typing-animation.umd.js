(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/Observable')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/core', 'rxjs/Observable'], factory) :
	(factory((global.ng = global.ng || {}, global.ng['angular-typing-animation'] = {}),global.ng.core,global.Observable));
}(this, (function (exports,core,Observable) { 'use strict';

var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var Typed = /** @class */ (function () {
    function Typed(element, options) {
        var defaults = {
            typeSpeed: 0,
            startDelay: 0,
            showCursor: true,
            hideCursorOnComplete: false,
            onComplete: function () { }
        };
        this.element = element;
        this.options = __assign({}, defaults, options);
        this.textContent = element.textContent.trim();
        this.strPos = 0;
        this.typingComplete = false;
        this.element.textContent = '';
        this.appendAnimationCss();
    }
    Typed.prototype.begin = function () {
        var _this = this;
        if (this.typingComplete) {
            return this.restart();
        }
        this.insertCursor();
        this.timeout = setTimeout(function () {
            _this.typewrite();
        }, this.options.startDelay);
    };
    Typed.prototype.typewrite = function () {
        var _this = this;
        var humanize = this.humanizer(this.options.typeSpeed);
        this.timeout = setTimeout(function () {
            _this.toggleBlinking(false);
            if (_this.strPos === _this.textContent.length) {
                _this.doneTyping();
            }
            else {
                _this.keepTyping();
            }
        }, humanize);
    };
    Typed.prototype.keepTyping = function () {
        if (this.strPos === 0) {
            this.toggleBlinking(false);
        }
        this.strPos += 1;
        var nextString = this.textContent.substr(0, this.strPos);
        this.replaceText(nextString);
        this.typewrite();
    };
    Typed.prototype.doneTyping = function () {
        this.toggleBlinking(true);
        if (this.textContent.length === this.strPos) {
            this.complete();
        }
    };
    Typed.prototype.complete = function () {
        if (this.options.hideCursorOnComplete) {
            this.removeCursor();
        }
        this.typingComplete = true;
        this.options.onComplete();
    };
    Typed.prototype.restart = function () {
        if (!this.typingComplete) {
            return;
        }
        clearTimeout(this.timeout);
        this.replaceText('');
        this.removeCursor();
        this.strPos = 0;
        this.typingComplete = false;
        this.begin();
    };
    Typed.prototype.insertCursor = function () {
        if (this.cursor) {
            return;
        }
        this.cursor = document.createElement('span');
        this.cursor.className = 'typed-cursor';
        this.cursor.innerHTML = '|';
        this.element.parentNode && this.element.parentNode.insertBefore(this.cursor, this.element.nextSibling);
    };
    Typed.prototype.removeCursor = function () {
        if (this.cursor && this.cursor.parentNode) {
            this.cursor.parentNode.removeChild(this.cursor);
            this.cursor = null;
        }
    };
    Typed.prototype.replaceText = function (str) {
        this.element.textContent = str;
    };
    Typed.prototype.humanizer = function (speed) {
        return Math.round(Math.random() * speed / 2) + speed;
    };
    Typed.prototype.toggleBlinking = function (isBlinking) {
        if (!this.cursor) {
            return;
        }
        if (this.cursorBlinking === isBlinking) {
            return;
        }
        this.cursorBlinking = isBlinking;
        var status = isBlinking ? 'infinite' : 0;
        this.cursor.style.animationIterationCount = status;
    };
    Typed.prototype.appendAnimationCss = function () {
        if (this.options.showCursor) {
            if (document.head.querySelector('#typing')) {
                return;
            }
            var css = document.createElement('style');
            css.type = 'text/css';
            css.id = 'typing';
            var innerCss = "\n                .typed-cursor{\n                    opacity: 1;\n                    animation: typedjsBlink 0.7s infinite;\n                    -webkit-animation: typedjsBlink 0.7s infinite;\n                    animation: typedjsBlink 0.7s infinite;\n                }\n                @keyframes typedjsBlink{\n                    50% { opacity: 0.0; }\n                }\n                @-webkit-keyframes typedjsBlink{\n                    0% { opacity: 1; }\n                    50% { opacity: 0.0; }\n                    100% { opacity: 1; }\n                }\n            ";
            css.innerHTML = innerCss;
            document.head.appendChild(css);
        }
    };
    return Typed;
}());

var TypingAnimationDirective = /** @class */ (function () {
    function TypingAnimationDirective(elRef) {
        this.elRef = elRef;
        this.typeSpeed = 0;
        this.startDelay = 0;
        this.condition = true;
        this.hideCursorOnComplete = false;
        this.complete = new core.EventEmitter();
        this.typingLock = false;
    }
    TypingAnimationDirective.prototype.ngOnInit = function () {
        if (!this.checkContent()) {
            return;
        }
        this.createTyped();
    };
    TypingAnimationDirective.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (this.typed) {
            return;
        }
        if (!this.checkContent()) {
            this.contentObservable = new Observable.Observable(function (ob) {
                if (_this.checkContent()) {
                    ob.next(_this.elRef.nativeElement.textContent.trim());
                    ob.complete();
                }
            });
            this.contentSubscription = this.contentObservable.subscribe(function (content) {
                _this.createTyped();
                _this.contentSubscription.unsubscribe();
            });
            return;
        }
        this.createTyped();
    };
    TypingAnimationDirective.prototype.ngOnChanges = function (changes) {
        if (('condition' in changes) && this.typed) {
            if (this.typingLock) {
                return;
            }
            if (this.condition) {
                this.typed.begin();
                this.typingLock = true;
            }
        }
    };
    TypingAnimationDirective.prototype.checkContent = function () {
        return this.elRef.nativeElement.textContent.trim().length > 0;
    };
    TypingAnimationDirective.prototype.createTyped = function () {
        var _this = this;
        this.typed = new Typed(this.elRef.nativeElement, {
            typeSpeed: this.typeSpeed,
            startDelay: this.startDelay,
            condition: this.condition,
            hideCursorOnComplete: this.hideCursorOnComplete,
            onComplete: function () {
                _this.complete.emit(null);
                _this.typingLock = false;
            }
        });
        if (this.condition) {
            this.typed.begin();
            this.typingLock = true;
        }
    };
    TypingAnimationDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[typingAnimation]'
                },] },
    ];
    /** @nocollapse */
    TypingAnimationDirective.ctorParameters = function () { return [
        { type: core.ElementRef, },
    ]; };
    TypingAnimationDirective.propDecorators = {
        'typeSpeed': [{ type: core.Input, args: ['typeSpeed',] },],
        'startDelay': [{ type: core.Input, args: ['startDelay',] },],
        'condition': [{ type: core.Input, args: ['condition',] },],
        'hideCursorOnComplete': [{ type: core.Input, args: ['hideCursorOnComplete',] },],
        'complete': [{ type: core.Output, args: ['complete',] },],
    };
    return TypingAnimationDirective;
}());

var TypingAnimationModule = /** @class */ (function () {
    function TypingAnimationModule() {
    }
    TypingAnimationModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [
                        TypingAnimationDirective
                    ],
                    exports: [
                        TypingAnimationDirective
                    ]
                },] },
    ];
    /** @nocollapse */
    TypingAnimationModule.ctorParameters = function () { return []; };
    return TypingAnimationModule;
}());

exports.TypingAnimationModule = TypingAnimationModule;
exports.TypingAnimationDirective = TypingAnimationDirective;

Object.defineProperty(exports, '__esModule', { value: true });

})));
