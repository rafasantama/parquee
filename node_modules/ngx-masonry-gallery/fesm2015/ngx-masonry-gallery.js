import { CommonModule } from '@angular/common';
import { EventEmitter, Component, ChangeDetectionStrategy, Renderer2, Input, Output, NgModule } from '@angular/core';
import imagesLoadedMethod from 'imagesloaded';
import * as masonry from 'masonry-layout';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class Utilities {
    /**
     * @return {?}
     */
    newGuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (/**
         * @param {?} c
         * @return {?}
         */
        function (c) {
            // tslint:disable-next-line:no-bitwise triple-equals
            /** @type {?} */
            const r = Math.random() * 16 | 0;
            /** @type {?} */
            const v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        }));
    }
}
/** @type {?} */
let utilities = new Utilities();

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MasonryGalleryComponent {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        this.renderer = renderer;
        this.images = [];
        this.width = 330;
        this.gutter = 5;
        this.verticalGutter = 5;
        this.imageClasses = [];
        this.clickImage = new EventEmitter();
        this.removeComplete = new EventEmitter();
        this.layoutComplete = new EventEmitter();
        this.galleryGuid = utilities.newGuid();
        this.mansonryItemSelectorClass = `grid-item-${this.galleryGuid}`;
        this.activeImages = [];
        this.viewReady = false;
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        if (changes.images && changes.images.currentValue) {
            if (!this.viewReady) {
                // process images once we can
                this.changesToProcess = changes;
            }
            else {
                this.processImages(changes);
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        if (this.msnry) {
            this.msnry.destroy();
        }
    }
    /**
     * @param {?} image
     * @return {?}
     */
    handleClick(image) {
        this.clickImage.next(image);
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.viewReady = true;
        this.initMasonry();
        // process images now
        if (this.changesToProcess) {
            this.processImages(this.changesToProcess);
            this.changesToProcess = undefined;
        }
    }
    /**
     * @param {?} images
     * @return {?}
     */
    addImages(images) {
        if (images && images.length > 0) {
            this.addImagesToGallery(images);
        }
    }
    /**
     * @param {?} images
     * @return {?}
     */
    removeImages(images) {
        if (images && images.length > 0) {
            images.forEach((/**
             * @param {?} image
             * @return {?}
             */
            image => {
                this.removeImageFromGallery(image);
            }));
        }
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    processImages(changes) {
        /** @type {?} */
        const imagesToProcess = this.getAddedAndRemovesImages(changes);
        // add images to mansonry layout
        this.addImages(imagesToProcess.addedImages);
        // removes images from layout
        this.removeImages(imagesToProcess.removedImages);
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    getAddedAndRemovesImages(changes) {
        /** @type {?} */
        let addedImages = [];
        /** @type {?} */
        const removedImages = [];
        /** @type {?} */
        const newImagesValue = (/** @type {?} */ (changes.images
            .currentValue));
        /** @type {?} */
        const oldImagesValue = (/** @type {?} */ (changes.images
            .previousValue));
        if (!oldImagesValue) {
            // all images are new ones
            addedImages = changes.images.currentValue;
        }
        else {
            // process added images
            newImagesValue.forEach((/**
             * @param {?} newImage
             * @return {?}
             */
            newImage => {
                /** @type {?} */
                const existingImage = oldImagesValue.find((/**
                 * @param {?} m
                 * @return {?}
                 */
                m => m.imageUrl.toLowerCase() === newImage.imageUrl.toLowerCase()));
                if (existingImage) ;
                else {
                    // image is new
                    addedImages.push(newImage);
                }
            }));
            // process removed images
            oldImagesValue.forEach((/**
             * @param {?} oldImage
             * @return {?}
             */
            oldImage => {
                /** @type {?} */
                const existingImage = newImagesValue.find((/**
                 * @param {?} m
                 * @return {?}
                 */
                m => m.imageUrl.toLowerCase() === oldImage.imageUrl.toLowerCase()));
                if (existingImage) ;
                else {
                    // image is removed
                    removedImages.push(oldImage);
                }
            }));
        }
        return {
            addedImages: addedImages,
            removedImages: removedImages
        };
    }
    /**
     * @private
     * @return {?}
     */
    initMasonry() {
        this.grid = document.getElementById(this.galleryGuid);
        // remove all existing data from grid
        this.grid.innerHTML = '';
        if (!this.grid) {
            throw Error(`Could not init mansory due to non existing elem with id '${this.galleryGuid}'`);
        }
        this.msnry = new masonry(this.grid, {
            // options...
            itemSelector: '.' + this.mansonryItemSelectorClass,
            columnWidth: this.width,
            gutter: this.gutter,
        });
        /** @type {?} */
        const that = this;
        this.msnry.on('layoutComplete', (/**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            that.layoutComplete.next(items);
        }));
        this.msnry.on('removeComplete', (/**
         * @param {?} items
         * @return {?}
         */
        function (items) {
            that.removeComplete.next(items);
        }));
    }
    /**
     * @private
     * @param {?} image
     * @return {?}
     */
    removeImageFromGallery(image) {
        // get image guid
        /** @type {?} */
        const imageIdResult = this.activeImages.find((/**
         * @param {?} m
         * @return {?}
         */
        m => m.image.imageUrl.toLowerCase() === image.imageUrl.toLowerCase()));
        if (!imageIdResult) {
            // image was not found, this is probably an error
            console.warn(`Image with url '${image.imageUrl}' was not found. If you are adding images, make sure to 'replace' the images array with a new one
                so that detection change can be executed instead of just adding an image to array
                (which doesn't fire change detection on array property)`);
            return;
        }
        // find image based on its id
        /** @type {?} */
        const imageElem = document.getElementById(imageIdResult.id);
        if (!imageElem) {
            // image was not found in DOM
            console.warn(`Image with id '{${imageIdResult.id}}' was not found in DOM. Have you manipulated the DOM in some way?`);
            return;
        }
        // remove image from gallery
        this.msnry.remove(imageElem);
        // refresh layout
        this.msnry.layout();
        // remove image from array
        for (let i = 0; i < this.activeImages.length; i++) {
            /** @type {?} */
            const idWithImage = this.activeImages[i];
            if (idWithImage.image.imageUrl.toLowerCase() ===
                imageIdResult.image.imageUrl.toLowerCase()) {
                this.activeImages.splice(i, 1);
            }
        }
    }
    /**
     * @private
     * @param {?} images
     * @return {?}
     */
    addImagesToGallery(images) {
        if (!this.grid) {
            throw Error('Grid element is not yet ready, are you trying to add image too soon?');
        }
        /** @type {?} */
        const imagesWrapper = this.renderer.createElement('span');
        images.forEach((/**
         * @param {?} image
         * @return {?}
         */
        image => {
            // generate unique image id
            /** @type {?} */
            const imageId = this.getImageId();
            // create element
            /** @type {?} */
            const imageElem = this.renderer.createElement('img');
            imageElem.setAttribute('id', imageId);
            imageElem.setAttribute('alt', image.alt ? image.alt : 'no description');
            imageElem.setAttribute('src', image.imageUrl);
            // note - images are hidden by default and should be shown only after they are loaded
            imageElem.setAttribute('style', `display: none; width: ${this.width}px; margin-bottom: ${this.verticalGutter}px`);
            imageElem.className = this.getImageClass();
            imageElem.addEventListener('click', (/**
             * @return {?}
             */
            () => {
                this.handleClick(image);
            }));
            // store guid with this image
            this.activeImages.push({
                id: imageId,
                image: image
            });
            // add to dom and mansory & refresh layout
            this.renderer.appendChild(imagesWrapper, imageElem);
        }));
        // add html to dom
        this.renderer.appendChild(this.grid, imagesWrapper);
        // add images once they are loaded
        /** @type {?} */
        const imgLoad = imagesLoadedMethod(imagesWrapper);
        imgLoad.on('progress', (/**
         * @param {?} instance
         * @param {?} image
         * @return {?}
         */
        (instance, image) => {
            if (image.isLoaded) {
                this.renderer.appendChild(this.grid, image.img);
                // unhide image
                this.renderer.setStyle(image.img, 'display', 'block');
                this.msnry.appended(image.img);
                this.msnry.reloadItems();
            }
        }));
    }
    /**
     * @private
     * @return {?}
     */
    getImageClass() {
        /** @type {?} */
        let className = this.mansonryItemSelectorClass;
        if (this.imageClasses && this.imageClasses.length > 0) {
            /** @type {?} */
            const customClass = this.imageClasses.join(' ');
            className += ' ' + customClass;
        }
        return className;
    }
    /**
     * @private
     * @return {?}
     */
    getImageId() {
        return this.galleryGuid + '_' + utilities.newGuid();
    }
}
MasonryGalleryComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'ngx-masonry-gallery',
                template: '<div [id]="galleryGuid"></div>'
            }] }
];
/** @nocollapse */
MasonryGalleryComponent.ctorParameters = () => [
    { type: Renderer2 }
];
MasonryGalleryComponent.propDecorators = {
    images: [{ type: Input }],
    width: [{ type: Input }],
    gutter: [{ type: Input }],
    verticalGutter: [{ type: Input }],
    imageClasses: [{ type: Input }],
    clickImage: [{ type: Output }],
    removeComplete: [{ type: Output }],
    layoutComplete: [{ type: Output }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class MasonryGalleryModule {
}
MasonryGalleryModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    MasonryGalleryComponent,
                ],
                exports: [
                    MasonryGalleryComponent,
                ],
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class IMasonryGalleryImage {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { IMasonryGalleryImage, MasonryGalleryComponent, MasonryGalleryModule };
//# sourceMappingURL=ngx-masonry-gallery.js.map
