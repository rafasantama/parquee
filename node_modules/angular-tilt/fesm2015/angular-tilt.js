import { Directive, ElementRef, Input, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class VanillaTilt {
    /**
     * @param {?} element
     * @param {?=} settings
     */
    constructor(element, settings = {}) {
        if (!(element instanceof Node)) {
            throw "Can't initialize VanillaTilt because " +
                element +
                " is not a Node.";
        }
        this.width = null;
        this.height = null;
        this.left = null;
        this.top = null;
        this.transitionTimeout = null;
        this.updateCall = null;
        this.updateBind = this.update.bind(this);
        this.resetBind = this.reset.bind(this);
        this.element = element;
        this.settings = this.extendSettings(settings);
        this.elementListener = this.getElementListener();
        this.reverse = this.settings.reverse ? -1 : 1;
        this.glare = this.isSettingTrue(this.settings.glare);
        this.glarePrerender = this.isSettingTrue(this.settings["glare-prerender"]);
        this.gyroscope = this.isSettingTrue(this.settings.gyroscope);
        if (this.glare) {
            this.prepareGlare();
        }
        this.addEventListeners();
    }
    /**
     * @param {?} setting
     * @return {?}
     */
    isSettingTrue(setting) {
        return setting === "" || setting === true || setting === 1;
    }
    /**
     * @return {?}
     */
    getElementListener() {
        if (!this.settings || !this.settings["mouse-event-element"]) {
            return this.element;
        }
        if (typeof this.settings["mouse-event-element"] === "string") {
            /** @type {?} */
            const mouseEventElement = document.querySelector(this.settings["mouse-event-element"]);
            if (mouseEventElement) {
                return mouseEventElement;
            }
        }
        if (this.settings["mouse-event-element"] instanceof Node) {
            return this.settings["mouse-event-element"];
        }
    }
    /**
     * @return {?}
     */
    addEventListeners() {
        this.onMouseEnterBind = this.onMouseEnter.bind(this);
        this.onMouseMoveBind = this.onMouseMove.bind(this);
        this.onMouseLeaveBind = this.onMouseLeave.bind(this);
        this.onWindowResizeBind = this.onWindowResize.bind(this);
        this.onDeviceOrientationBind = this.onDeviceOrientation.bind(this);
        this.elementListener.addEventListener("mouseenter", this.onMouseEnterBind);
        this.elementListener.addEventListener("mousemove", this.onMouseMoveBind);
        this.elementListener.addEventListener("mouseleave", this.onMouseLeaveBind);
        if (this.glare) {
            window.addEventListener("resize", this.onWindowResizeBind);
        }
        if (this.gyroscope) {
            window.addEventListener("deviceorientation", this.onDeviceOrientationBind);
        }
    }
    /**
     * Method remove event listeners from current this.elementListener
     * @return {?}
     */
    removeEventListeners() {
        this.elementListener.removeEventListener("mouseenter", this.onMouseEnterBind);
        this.elementListener.removeEventListener("mousemove", this.onMouseMoveBind);
        this.elementListener.removeEventListener("mouseleave", this.onMouseLeaveBind);
        if (this.gyroscope) {
            window.removeEventListener("deviceorientation", this.onDeviceOrientationBind);
        }
        if (this.glare) {
            window.removeEventListener("resize", this.onWindowResizeBind);
        }
    }
    /**
     * @return {?}
     */
    destroy() {
        clearTimeout(this.transitionTimeout);
        if (this.updateCall !== null) {
            cancelAnimationFrame(this.updateCall);
        }
        this.reset();
        this.removeEventListeners();
        this.element.vanillaTilt = null;
        delete this.element.vanillaTilt;
        this.element = null;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onDeviceOrientation(event) {
        if (event.gamma === null || event.beta === null) {
            return;
        }
        this.updateElementPosition();
        /** @type {?} */
        const totalAngleX = this.settings.gyroscopeMaxAngleX - this.settings.gyroscopeMinAngleX;
        /** @type {?} */
        const totalAngleY = this.settings.gyroscopeMaxAngleY - this.settings.gyroscopeMinAngleY;
        /** @type {?} */
        const degreesPerPixelX = totalAngleX / this.width;
        /** @type {?} */
        const degreesPerPixelY = totalAngleY / this.height;
        /** @type {?} */
        const angleX = event.gamma - this.settings.gyroscopeMinAngleX;
        /** @type {?} */
        const angleY = event.beta - this.settings.gyroscopeMinAngleY;
        /** @type {?} */
        const posX = angleX / degreesPerPixelX;
        /** @type {?} */
        const posY = angleY / degreesPerPixelY;
        if (this.updateCall !== null) {
            cancelAnimationFrame(this.updateCall);
        }
        this.event = {
            clientX: posX + this.left,
            clientY: posY + this.top
        };
        this.updateCall = requestAnimationFrame(this.updateBind);
    }
    /**
     * @return {?}
     */
    onMouseEnter() {
        this.updateElementPosition();
        this.element.style.willChange = "transform";
        this.setTransition();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onMouseMove(event) {
        if (this.updateCall !== null) {
            cancelAnimationFrame(this.updateCall);
        }
        this.event = event;
        this.updateCall = requestAnimationFrame(this.updateBind);
    }
    /**
     * @return {?}
     */
    onMouseLeave() {
        this.setTransition();
        if (this.settings.reset) {
            requestAnimationFrame(this.resetBind);
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.event = {
            pageX: this.left + this.width / 2,
            pageY: this.top + this.height / 2
        };
        if (this.element && this.element.style) {
            this.element.style.transform =
                `perspective(${this.settings.perspective}px) ` +
                    `rotateX(0deg) ` +
                    `rotateY(0deg) ` +
                    `scale3d(1, 1, 1)`;
        }
        if (this.glare) {
            this.glareElement.style.transform =
                "rotate(180deg) translate(-50%, -50%)";
            this.glareElement.style.opacity = "0";
        }
    }
    /**
     * @return {?}
     */
    getValues() {
        /** @type {?} */
        let x = (this.event.clientX - this.left) / this.width;
        /** @type {?} */
        let y = (this.event.clientY - this.top) / this.height;
        x = Math.min(Math.max(x, 0), 1);
        y = Math.min(Math.max(y, 0), 1);
        /** @type {?} */
        let tiltX = (this.reverse *
            (this.settings.max / 2 - x * this.settings.max)).toFixed(2);
        /** @type {?} */
        let tiltY = (this.reverse *
            (y * this.settings.max - this.settings.max / 2)).toFixed(2);
        /** @type {?} */
        let angle = Math.atan2(this.event.clientX - (this.left + this.width / 2), -(this.event.clientY - (this.top + this.height / 2))) *
            (180 / Math.PI);
        return {
            tiltX: tiltX,
            tiltY: tiltY,
            percentageX: x * 100,
            percentageY: y * 100,
            angle: angle
        };
    }
    /**
     * @return {?}
     */
    updateElementPosition() {
        /** @type {?} */
        let rect = this.element.getBoundingClientRect();
        this.width = this.element.offsetWidth;
        this.height = this.element.offsetHeight;
        this.left = rect.left;
        this.top = rect.top;
    }
    /**
     * @return {?}
     */
    update() {
        /** @type {?} */
        let values = this.getValues();
        this.element.style.transform =
            "perspective(" +
                this.settings.perspective +
                "px) " +
                "rotateX(" +
                (this.settings.axis === "x" ? 0 : values.tiltY) +
                "deg) " +
                "rotateY(" +
                (this.settings.axis === "y" ? 0 : values.tiltX) +
                "deg) " +
                "scale3d(" +
                this.settings.scale +
                ", " +
                this.settings.scale +
                ", " +
                this.settings.scale +
                ")";
        if (this.glare) {
            this.glareElement.style.transform = `rotate(${values.angle}deg) translate(-50%, -50%)`;
            this.glareElement.style.opacity = `${(values.percentageY *
                this.settings["max-glare"]) /
                100}`;
        }
        this.element.dispatchEvent(new CustomEvent("tiltChange", {
            detail: values
        }));
        this.updateCall = null;
    }
    /**
     * Appends the glare element (if glarePrerender equals false)
     * and sets the default style
     * @return {?}
     */
    prepareGlare() {
        // If option pre-render is enabled we assume all html/css is present for an optimal glare effect.
        if (!this.glarePrerender) {
            // Create glare element
            /** @type {?} */
            const jsTiltGlare = document.createElement("div");
            jsTiltGlare.classList.add("js-tilt-glare");
            /** @type {?} */
            const jsTiltGlareInner = document.createElement("div");
            jsTiltGlareInner.classList.add("js-tilt-glare-inner");
            jsTiltGlare.appendChild(jsTiltGlareInner);
            this.element.appendChild(jsTiltGlare);
        }
        this.glareElementWrapper = this.element.querySelector(".js-tilt-glare");
        this.glareElement = this.element.querySelector(".js-tilt-glare-inner");
        if (this.glarePrerender) {
            return;
        }
        Object.assign(this.glareElementWrapper.style, {
            position: "absolute",
            top: "0",
            left: "0",
            width: "100%",
            height: "100%",
            overflow: "hidden",
            "pointer-events": "none"
        });
        Object.assign(this.glareElement.style, {
            position: "absolute",
            top: "50%",
            left: "50%",
            "pointer-events": "none",
            "background-image": `linear-gradient(0deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%)`,
            width: `${this.element.offsetWidth * 2}px`,
            height: `${this.element.offsetWidth * 2}px`,
            transform: "rotate(180deg) translate(-50%, -50%)",
            "transform-origin": "0% 0%",
            opacity: "0"
        });
    }
    /**
     * @return {?}
     */
    updateGlareSize() {
        Object.assign(this.glareElement.style, {
            width: `${this.element.offsetWidth * 2}`,
            height: `${this.element.offsetWidth * 2}`
        });
    }
    /**
     * @return {?}
     */
    onWindowResize() {
        this.updateGlareSize();
    }
    /**
     * @return {?}
     */
    setTransition() {
        clearTimeout(this.transitionTimeout);
        this.element.style.transition =
            this.settings.speed + "ms " + this.settings.easing;
        if (this.glare)
            this.glareElement.style.transition = `opacity ${this.settings.speed}ms ${this.settings.easing}`;
        this.transitionTimeout = setTimeout((/**
         * @return {?}
         */
        () => {
            this.element.style.transition = "";
            if (this.glare) {
                this.glareElement.style.transition = "";
            }
        }), this.settings.speed);
    }
    /**
     * @param {?} settings
     * @return {?}
     */
    extendSettings(settings) {
        /** @type {?} */
        let defaultSettings = {
            reverse: false,
            max: 35,
            perspective: 1000,
            easing: "cubic-bezier(.03,.98,.52,.99)",
            scale: 1,
            speed: 300,
            transition: true,
            axis: null,
            glare: false,
            "max-glare": 1,
            "glare-prerender": false,
            "mouse-event-element": null,
            reset: true,
            gyroscope: true,
            gyroscopeMinAngleX: -45,
            gyroscopeMaxAngleX: 45,
            gyroscopeMinAngleY: -45,
            gyroscopeMaxAngleY: 45
        };
        /** @type {?} */
        let newSettings = {};
        for (var property in defaultSettings) {
            if (property in settings) {
                newSettings[property] = settings[property];
            }
            else if (this.element.hasAttribute("data-tilt-" + property)) {
                /** @type {?} */
                let attribute = this.element.getAttribute("data-tilt-" + property);
                try {
                    newSettings[property] = JSON.parse(attribute);
                }
                catch (e) {
                    newSettings[property] = attribute;
                }
            }
            else {
                newSettings[property] = defaultSettings[property];
            }
        }
        return newSettings;
    }
    /**
     * @param {?} elements
     * @param {?} settings
     * @return {?}
     */
    static init(elements, settings) {
        if (elements instanceof Node) {
            elements = [elements];
        }
        if (elements instanceof NodeList) {
            elements = [].slice.call(elements);
        }
        if (!(elements instanceof Array)) {
            return;
        }
        elements.forEach((/**
         * @param {?} element
         * @return {?}
         */
        element => {
            if (!("vanillaTilt" in element)) {
                element.vanillaTilt = new VanillaTilt(element, settings);
            }
        }));
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AngularTiltDirective {
    /**
     * @param {?} el
     */
    constructor(el) {
        this.el = el;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.tilt = new VanillaTilt(this.el.nativeElement, this.tiltSettings);
    }
}
AngularTiltDirective.decorators = [
    { type: Directive, args: [{
                selector: "[aTilt]"
            },] }
];
/** @nocollapse */
AngularTiltDirective.ctorParameters = () => [
    { type: ElementRef }
];
AngularTiltDirective.propDecorators = {
    tiltSettings: [{ type: Input, args: ["tiltSettings",] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class AngularTiltModule {
}
AngularTiltModule.decorators = [
    { type: NgModule, args: [{
                declarations: [AngularTiltDirective],
                imports: [],
                exports: [AngularTiltDirective]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { AngularTiltModule, AngularTiltDirective as ɵa };

//# sourceMappingURL=angular-tilt.js.map